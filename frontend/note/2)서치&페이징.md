## 2) 키워드(프론트 필터) + 현재 페이지
- 데이터량이 적거나, 이미 목록 전체를 한 번에 불러온 경우
예: 드롭다운 검색, 로컬 캐싱 데이터 필터


#  const PAGE_SIZE = 5;
  : 한 페이지에 몇 개 보여줄지 상수.
#  const [keyword, setKeyword] = useState('');
  : 기본 '' 공백
  - keyword: 검색창에 입력된 문자열 상태
  - setKeyword: 검색어를 바꾸는 함수
#  const [page, setPage] = useState(0);
  : 기본값 0부터 시작 (0=1페이지)
  - page: 현재 페이지 번호 (0부터 시작)
  - setPage: 페이지 번호를 바꾸는 함수

## 🍼 useState란? [훅(Hook)]
- 리액트가 제공하는 함수 (리액트 코어 라이브러리에 내장)
- 컴포넌트 안에서 상태(state) 변수를 만들고 관리할 수 있게 해줌.
- 그냥 let이나 const 변수랑 다른 점은 값이 바뀌면 화면을 다시 그려준다는 것.
- useState는 “변할 수 있는 값”을 위한 것.
- 예) 검색어, 현재 페이지 번호, 체크박스 상태, 로그인 여부 등

  (JS 변수(let a = 0)는 값이 변해도 리액트에서는 값 변경X
  useState로 만든 변수는 값이 변하면 자동으로 컴포넌트를 다시 실행하여 최신 값 화면 반영)
  
## 그렇다면 useState를 사용하지 않는 변수는?
- 렌더링 중에 바뀔 일이 없는 상수일 때 사용
- 예) 스타일 클래스, API 주소, 메뉴 목록, 상수값(페이지 크기 등)



# 사용법
# const [state, setState] = useState(초기값);
- state → 상태 변수 (읽기 전용)
- setState → 상태 값을 바꾸는 함수 (setter)
- useState(초기값) → 상태 변수의 초기값 설정


## 🍼 useMemo란? [훅(Hook)]
- 계산 결과를 기억(캐싱)했다가, 의존 값이 바뀔 때만 다시 계산.
- const filtered = useMemo(() => {
-   const q = keyword.trim().toLowerCase();
- keyword가 바뀔 때 마다 필터링 로직을 다시 돌림

- useMemo없이도 동작은 똑같지만, 계산 결과를 캐싱해두면 랜더링 때 마다 불필요하게 실행하지 않을 수 있음.

# trim()
문자열 앞뒤의 공백을 없앰.
" abc ".trim() → "abc"

# toLowerCase()
문자열을 소문자로 변환하는 JS 기본 함수.
이유: 검색 시 대소문자 구분을 없애기 위해서.

- items.filter(r =>
  [r.title, r.writer].some(v => (v || '').toLowerCase().includes(q))
);

# filter()
조건에 맞는 요소만 골라서 새 배열 생성.

# [r.title, r.writer]
제목과 작성자를 배열로 묶음.

# .some(...)
배열 안 요소 중 하나라도 조건을 만족하면 true.
( (v || '') = 혹시 값이 null이나 undefined여도 빈 문자열로 처리해서 에러 방지)

# .includes(q)
검색어 q가 포함되어 있는지 확인

# useMemo(() => { ... }, [keyword, items]);
# = [keyword, items] : 의존성 배열(dependency array)
- keyword나 items가 바뀔 때만 이 계산 함수를 다시 실행하라.

- useMemo는 "계산 결과를 기억"하는 훅이니까, 언제 다시 계산할지를 알려줘야 함.
- [] 안에 있는 값이 변할 때만 첫 번째 함수(() => { ... })를 다시 실행함.
그 외에는 이전에 계산해둔 값을 그대로 재사용.


## 🍼 클라 사이드 페이징

# 1) 전체 개수 계산
- const total = filtered.length;
* filtered: 검색어 적용 후의 목록.
* total: 지금 화면에 “후보”로 남은 전체 데이터 개수.
예) 데이터 13개면 total = 13

# 2) 총 페이지 수 계산
- const PAGE_SIZE = 5; // 한 페이지 몇 개?
- const totalPages = Math.max(1, Math.ceil(total / PAGE_SIZE));

* Math.ceil(13/5) = 3 → 총 3페이지
* Math.max(1, …)을 쓰는 이유: 데이터가 0개여도 페이지 표시를 1은 유지하려고(UX 안정)
* 페이지 인덱스는 0부터 시작 ⇒ 마지막 페이지 인덱스는 totalPages - 1

# 3) 현재 페이지 안전 보정
- const current = Math.min(page, totalPages - 1);
* 검색어 바뀌거나 총 페이지 수가 줄었는데도 page가 큰 값으로 남아 있으면 빈 화면 위험.
* 항상 현재 페이지 ≤ 마지막 페이지가 되도록 보정.
* (반대로 0보다 작아지는 건 goPage에서 막아줌)

# 4) 슬라이스 범위 계산
- const start = current * PAGE_SIZE;
- const end = start + PAGE_SIZE;
- const pageItems = filtered.slice(start, end);

* slice(start, end)는 end 미포함이야.
예) current=0일 때
start=0, end=5 → 0~4 인덱스 5개
예) current=2(3페이지)일 때
start=10, end=15 → 10~14 인덱스
데이터가 13개면 실제로는 10,11,12까지만 존재 → slice가 자동으로 안전하게 잘라줌.

# 5) 페이지 이동 함수(안전 버전)
- function goPage(p) {
-  const safe = Math.min(Math.max(0, p), totalPages - 1);
-  setPage(safe);
- }
* Math.max(0, p)로 음수 방지
* Math.min(…, totalPages - 1)로 마지막 페이지 초과 방지


### 플러그인/라이브러리

# 1) React-Bootstrap
- 설치 : npm install react-bootstrap bootstrap

* .jsx
import Pagination from 'react-bootstrap/Pagination';
<Pagination>
  <Pagination.First />
  <Pagination.Prev />
  <Pagination.Item active>{1}</Pagination.Item>
  <Pagination.Item>{2}</Pagination.Item>
  <Pagination.Next />
  <Pagination.Last />
</Pagination>

# 2) MUI
- 설치 : npm install @mui/material @emotion/react @emotion/styled

* .jsx
import Pagination from '@mui/material/Pagination';
<Pagination count={totalPages} page={page+1} onChange={(e, p) => setPage(p-1)} />
